# -*- coding: utf-8 -*-
"""lab2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cpJmRsltvZx5FQw87V0TW2q9l3FX196e
"""

class Stack:
  def __init__(self):
    self.items= []

  def pop(self):
    if self.isEmpty():
      raise RuntimeError("Attempt to pop an empty stack")
    topIdx= len(self.items)-1
    item = self.items[topIdx]
    del self.items[topIdx]
    return item

  def push(self,item):
    self.items.append(item)

  def top(self):
    if self.isEmpty():
      raise RuntimeError("Attempt to get top of empty stack")
    topIdx= len(self.items)-1
    return self.items[topIdx]

  def isEmpty(self):
    return len(self.items) == 0

  def clear(self):
    self.items= []

class Queue:
 def __init__(self):
  self.items = []
  self.frontIdx = 0

 def __compress(self):
  newlst = []
  for i in range(self.frontIdx,len(self.items)):
   newlst.append(self.items[i])

  self.items = newlst
  self.frontIdx = 0

 def dequeue(self):
  if self.isEmpty():
   raise RuntimeError("Attempt to dequeue an empty queue")

 # When queue is half full, compress it. This
 # achieves an amortized complexity of O(1) while
 # not letting the list continue to grow unchecked.
  if self.frontIdx * 2 > len(self.items):
   self.__compress()

  item = self.items[self.frontIdx]
  self.frontIdx += 1
  return item

 def enqueue(self,item):
  self.items.append(item)
  
 def qlen(self):
  return len(self.items[self.frontIdx:])
